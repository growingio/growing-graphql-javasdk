# Created automatically at 2020-08-18T19:58:27.917. Don't modify it
type Query {

    personaMeasurements: [Measurement]

    segmentMeasurements(policy: SettingSegmentMeasurementPolicy!, id: HashId): [Measurement]

    utmArguments: [UtmArgument]

    projectInfo: ProjectInfo!

    originDataSettings: [OriginDataSetting]!

    tags: [Tag]

    tag(id: HashId!): Tag

    countTags: Int

    segments: [Segment]

    segment(id: HashId!): Segment

    countSegments: Int

    basicProfile(id: String!): BasicProfile

    personaProfile(id: String!): PersonaProfile

    userProfile(userId: String, tags: [HashId!], properties: [String!]): UserProfile

    userEventsTrend(id: String!): EventTrend

    searchUsers(q: String!): [UserSearch]

    users(type: UserQueryType!, id: String!, offset: Int, limit: Int): SlicePagination!

    activeUsers(timeRange: String!, offset: Int, limit: Int): SlicePagination!

    userEvents(id: String!, type: UserEventType!, timeRange: String, first: Int, after: String, last: Int, before: String): CursorPagination!

    searchUserEvents(id: String!, q: String!, timeRange: String): [String!]!

    # activeToday: 今日活跃用户
    # activeInThreeWeeks: 近 3 周活跃用户
    # activeNotInTwoWeeks: 近 2 周不活跃用户
    preparedSegment(id: String): PreparedSegment

    segmentDocument(id: HashId!): SegmentDocument
    tunnels: [Tunnel]

    tunnel(id: HashId!): Tunnel

    countTunnels: Int

    ubaCustomEvents(tunnelId: HashId!): [CustomEvent]

    ubaUserVariables(tunnelId: HashId!): [UserVariable]

    tunnelActivated(id: HashId!): Boolean!

    getTunnelEventsTrend(id: HashId): TunnelEventsTrend

    jobResult(id: String!): JobResult

    eventImportJobs: [EventImportJob!]

    jobLogs(id: HashId!): [LogEntry!]

    jobFiles(id: HashId!): [FileDescriptor!]

    subscriptions(type: SubscriptionType): [Subscription!]
    features: [Feature!]!
    version: String!

    userPermissionModules(userId: HashId!): [Module]

    permissionModules: [Module]

    role(id:HashId!): Role

    roles: [Role]

    acls(resourceType: String): [UserAccessCtrl]

    resourceActions(resourceType: String, resourceId: Long): [String]

    userGrants(resourceType: String, resourceId: Long): AccessEntry

    departments(parentId: String): [Department!]
    
    allDepartments: [Department!]


    customEvents: [CustomEvent]

    customEvent(id: HashId!): CustomEvent

    countCustomEvents: Int

    complexMetrics: [ComplexMetric]

    complexMetric(id: HashId!): ComplexMetric

    preparedMetrics: [PreparedMetric]

    countComplexMetrics: Int

    eventVariables: [EventVariable]

    eventVariable(id: HashId!): EventVariable

    countEventVariables: Int

    itemModels: [ItemModel]

    itemModel(id: HashId!): ItemModel

    itemVariables: [ItemVariable]

    itemVariable(id: HashId!): ItemVariable

    countItemVariables: Int

    userVariables: [UserVariable]

    userVariable(id: HashId!): UserVariable

    countUserVariables: Int

    userProperties: [UserProperty]

    preparedDimensions: [PreparedDimension]

    measurements(t: [String], q: String, c: String): [Measurable]

    insightDimensions(measurements: [MeasurementInput], targetUsers: [String]): [Dimension]



    kpiAnalysis(id:HashId!, dashboardId: String): KpiAnalysis

    kpiAnalyses: [KpiAnalysis]

    countKpiAnalyses: Int

    funnelAnalysis(id:HashId!, dashboardId: String): FunnelAnalysis

    funnelAnalyses: [FunnelAnalysis]

    countFunnelAnalyses: Int

    frequencyAnalysis(id:HashId!, dashboardId: String): FrequencyAnalysis

    frequencyAnalyses: [FrequencyAnalysis]

    countFrequencyAnalyses: Int

    eventAnalysis(id:HashId!, dashboardId: String): EventAnalysis

    eventAnalyses: [EventAnalysis]

    countEventAnalyses: Int

    retentionAnalysis(id:HashId!, dashboardId: String): RetentionAnalysis

    retentionAnalyses: [RetentionAnalysis]

    countRetentionAnalyses: Int

    dashboard(id:HashId!): Dashboard

    dashboards: [Dashboard]

    countDashboards: Int

    analysisDashboardReferers(resourceType:String!, resourceId:HashId!): [DashboardReference]

    dashboardComment(id: HashId!): DashboardComment
}

type Mutation {

    settingUtmArguments(utmArguments: [UtmArgumentInput!]!): Boolean!

    deleteUtmArgument(id: HashId!): Boolean!

    settingPersonaMeasurements(measurements: [MeasurementInput!]!): Boolean!

    settingSegmentMeasurements(policy: SettingSegmentMeasurementPolicy!, measurements: [MeasurementInput!]!, id: HashId): Boolean!

    updateProjectInfo(projectInfo: ProjectInfoInput): Boolean!

    updateOriginDataSetting(originDatas: [OriginDataSettingInput!]!): Boolean!


    createTag(tag: TagInput!): Tag!

    deleteTag(id: HashId!): Boolean

    updateTag(id: HashId!, tag: TagInput!): Tag

    batchDeleteTags(ids: [HashId!]): Boolean

    createSegment(segment: SegmentInput!): Segment!

    deleteSegment(id: HashId!): Boolean

    updateSegment(id: HashId!, segment: SegmentInput!): Segment

    batchDeleteSegments(ids: [HashId!]): Boolean

    createSegmentSnapshot(compute: ComputeDefinitionInput!): SegmentSnapshot!


    deleteTunnel(id: HashId!): Boolean

    createTunnel(tunnel: TunnelInput!): Tunnel!

    updateTunnel(id: HashId!, tunnel: TunnelInput!): Tunnel

    batchDeleteTunnels(ids: [HashId!]!): Boolean

    syncUbaCustomEvent(tunnelId: HashId!, ubaCustomEvents: [UbaCustomEventInput]!): [CustomEvent]!

    syncUbaUserVariable(tunnelId: HashId!, ubaUserVariables: [UbaUserVariableInput]!): [UserVariable]!

    executeJob(id: HashId!): JobResult

    createEventImportJob(tunnelId: HashId!, timeRange: String): EventImportJob!

    submitTagUserExportJob(tagId: HashId!, properties: [String!], charset: String): TagUserExportJob!

    submitSegmentUserExportJob(segmentId: HashId!, tags: [HashId!], properties: [String!], charset: String): SegmentUserExportJob!

    submitSegmentSnapshotUserExportJob(id: String!, properties: [String!], charset: String): SegmentUserExportJob!

    submitAnalysisExportJob(id: HashId!, param: AnalysisExportJobParam!, charset: String): AnalysisExportJob!


    createSubscription(type: SubscriptionType, id: HashId!): Boolean

    deleteSubscription(type: SubscriptionType, id: HashId!): Boolean

    batchUpdateSubscriptions(type: SubscriptionType, subscriptions: [SubscriptionInput!]): Boolean


    roleAppendUser(roleName:String!, userId:HashId!):Boolean

    updateUserPermissions(userId:HashId!, roleId: HashId!, permissions:[HashId!]):Boolean

    updateResourceAcls(resourceType: String, resourceId: HashId!, accessEntry: AccessEntryInput): Boolean

    batchUpdateResourceAcl(resourceType: String, resourceIds: [HashId!]!, readers: [HashId!], editors: [HashId!]): Boolean

    createRole(role: RoleInput!): Role!

    deleteRole(id: HashId!): Boolean

    updateRole(id: HashId!, role: RoleInput!): Boolean

    createDepartment(department: DepartmentInput): Department!

    updateDepartment(id: HashId!, department: DepartmentInput!): Department!

    deleteDepartment(id: HashId!): Boolean!

    addMembersToDepartment(memberIds: [HashId!]!, departmentId: String): Boolean!

    updateMemberRole(memberId:HashId!, roleId: HashId!): Boolean!

    createAccount(email: String!, roleId: HashId!, permissions: [HashId!]!, extra: String): CreateAccountReply

    disableAccount(id:HashId!): Boolean

    resetAccountPassword(id:HashId!): String!

    createMember(input: MemberInput!): Member!

    resetPassword(input: ResetPasswordInput): Boolean!

    updateMember(id: HashId!, input: MemberInput): Boolean!


    createCustomEvent(customEvent: CustomEventInput!): CustomEvent!

    updateCustomEvent(id: HashId!, customEvent: CustomEventInput!): CustomEvent!

    deleteCustomEvent(id: HashId!): Boolean

    batchDeleteCustomEvents(ids: [HashId!]!): Boolean

    createComplexMetric(complexMetric: ComplexMetricInput!): ComplexMetric!

    updateComplexMetric(id: HashId!, complexMetric: ComplexMetricInput!): ComplexMetric!

    deleteComplexMetric(id: HashId!): Boolean

    batchDeleteComplexMetrics(ids: [HashId!]!): Boolean

    createEventVariable(eventVariable: VariableInput!): EventVariable!

    updateEventVariable(id: HashId!, eventVariable: VariableInput!): EventVariable!

    deleteEventVariable(id: HashId!): Boolean!

    batchDeleteEventVariables(ids: [HashId!]!): Boolean

    createItemVariable(itemVariable: VariableInput!): ItemVariable!

    updateItemVariable(id: HashId!, itemVariable: VariableInput!): ItemVariable!

    deleteItemVariable(id: HashId!): Boolean!

    batchDeleteItemVariables(ids: [HashId!]!): Boolean

    createItemModel(itemModel: ItemModelInput!): ItemModel!

    updateItemModel(id: HashId!, itemModel: ItemModelInput!): ItemModel!

    deleteItemModel(id: HashId!): Boolean!

    batchDeleteItemModels(ids: [HashId!]!): Boolean

    addItemModelAttribute(id: HashId!, attribute: ItemVariableInput!): ItemVariable

    createUserVariable(userVariable: VariableInput!): UserVariable!

    updateUserVariable(id: HashId!, userVariable: VariableInput!): UserVariable!

    deleteUserVariable(id: HashId!): Boolean!

    batchDeleteUserVariables(ids: [HashId!]!): Boolean


    createKpiAnalysis(kpiAnalysis: KpiAnalysisInput!): KpiAnalysis!

    updateKpiAnalysis(id: HashId!, kpiAnalysis: KpiAnalysisInput!): KpiAnalysis!

    deleteKpiAnalysis(id: HashId!): Boolean!

    batchDeleteKpiAnalyses(ids: [HashId!]!): Boolean

    createFunnelAnalysis(funnelAnalysis: FunnelAnalysisInput!): FunnelAnalysis!

    updateFunnelAnalysis(id: HashId!, funnelAnalysis: FunnelAnalysisInput!): FunnelAnalysis!

    deleteFunnelAnalysis(id: HashId!): Boolean!

    batchDeleteFunnelAnalyses(ids: [HashId!]!): Boolean

    createFrequencyAnalysis(frequencyAnalysis: FrequencyAnalysisInput!): FrequencyAnalysis!

    updateFrequencyAnalysis(id: HashId!, frequencyAnalysis: FrequencyAnalysisInput!): FrequencyAnalysis!

    deleteFrequencyAnalysis(id: HashId!): Boolean!

    batchDeleteFrequencyAnalyses(ids: [HashId!]!): Boolean

    createEventAnalysis(eventAnalysis: EventAnalysisInput!): EventAnalysis!

    updateEventAnalysis(id: HashId!, eventAnalysis: EventAnalysisInput!): EventAnalysis!

    deleteEventAnalysis(id: HashId!): Boolean!

    batchDeleteEventAnalyses(ids: [HashId!]!): Boolean

    createRetentionAnalysis(retentionAnalysis: RetentionAnalysisInput!): RetentionAnalysis!

    updateRetentionAnalysis(id: HashId!, retentionAnalysis: RetentionAnalysisInput!): RetentionAnalysis!

    deleteRetentionAnalysis(id: HashId!): Boolean!

    batchDeleteRetentionAnalyses(ids: [HashId!]!): Boolean

    createDashboard(dashboard: DashboardInput!): Dashboard!

    updateDashboard(id: HashId!, dashboard: DashboardInput!): Dashboard!

    deleteDashboard(id: HashId!): Boolean!

    batchDeleteDashboards(ids: [HashId!]!): Boolean

    updateDashboardComment(id: HashId!, dashboardComment: DashboardCommentInput!): DashboardComment!

    deleteDashboardComment(id: HashId!): Boolean!

    createDashboardComment(dashboardComment: DashboardCommentInput!): DashboardComment!

    createFunnelDrillDownSegment(funnelDrillDownSegment:FunnelDrillDownSegmentInput!): DrillDownSegmentReply!

    createRetentionDrillDownSegment(retentionDrillDownSegment:RetentionDrillDownSegmentInput!): DrillDownSegmentReply!

    createFrequencyDrillDownSegment(frequencyDrillDownSegment:FrequencyDrillDownSegmentInput!): DrillDownSegmentReply!

    createFunnelDrillDownSegmentSnapshot(funnelDrillDownSegment:FunnelDrillDownSegmentInput!): DrillDownSegmentSnapshotReply!

    createRetentionDrillDownSegmentSnapshot(retentionDrillDownSegment:RetentionDrillDownSegmentInput!): DrillDownSegmentSnapshotReply!

    createFrequencyDrillDownSegmentSnapshot(frequencyDrillDownSegment:FrequencyDrillDownSegmentInput!): DrillDownSegmentSnapshotReply!
}

directive @subscriptions on FIELD_DEFINITION

enum SubscriptionType {
    DASHBOARD
}

type Subscription {
    id: String,
    name: String,
    status: String,
    children: [Subscription!] @subscriptions
}

input SubscriptionInput {
    id: String,
    name: String,
    children: [SubscriptionInput]
}

enum SettingSegmentMeasurementPolicy {
    APPLY_TO_MEMBER, APPLY_TO_SEGMENT
}

type ProjectInfo {
    id: HashId!
    name: String!
    logo: String @option
    createdAt: DateTime!
}

input ProjectInfoInput {
    name: String
    logo: String
}

type OriginDataSetting {
    key: String!
    dayTTL: Long
}

input OriginDataSettingInput {
    key: String!
    dayTTL: Long!
}

input UtmArgumentInput {
    utmKey: String!
    userKey: String!
}

type UtmArgument {
    id: HashId!
    utmKey: String!
    userKey: String!
}
directive @roleUsers on FIELD_DEFINITION
directive @rolePermissions on FIELD_DEFINITION
directive @departments on FIELD_DEFINITION
directive @departmentMembers on FIELD_DEFINITION
directive @departmentMemberCount on FIELD_DEFINITION

type Group {
    id: HashId
    name: String
}

type Role {
    id: HashId
    name: String
    description: String
    members: [Member!] @roleUsers
    permissions: [Permission!] @rolePermissions
    isSystem: Boolean
    isRoot: Boolean
    isTechSupport: Boolean
}

type AccessEntry {
    isPublic: Boolean
    members: [HashId!] @fetch(from: "usersList")
    groups: [Group!] @fetch(from: "groupsList")
    actions: [String!] @fetch(from: "actionsList")
}

type UserAccessCtrl {
    resourceId: HashId
    resourceType: String
    memberId: HashId
    actions: [String!]
}

type Permission {
    id: HashId
    action: String
    name: String
}

type Module {
    key: String
    name: String
    permissions: [Permission!] @fetch(from: "permissionsList")
}

type ObjectIdentity {
    resourceId: HashId
    resourceType: String
}

input RoleInput {
    name: String!,
    description: String,
    permissions: [HashId!],
    members: [HashId!]
}

type Department {
    id: HashId!
    name: String!
    parentId: String!
    departments: [Department!] @departments
    members: [Member!] @departmentMembers
    memberCount: Int! @departmentMemberCount
}

input AccessEntryInput {
    isPublic: Boolean
    members: [HashId!]
    groups: [HashId!]
    actions: [String!]
}

input ModuleInput {
    key: String!
    permissions: [PermissionInput!]
}

input PermissionInput {
    action: String!
}

input DepartmentInput {
    name: String!,
    parentId: String,
    members: [HashId!]
}

type Tunnel implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    type: String!
    config: TunnelConfig @option
    description: String @option
    key: String!
    projectKey: String!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
}

type JDBCTunnelConfig {
    url: String!
    username: String!
    password: String!
}

type GIOApiTunnelConfig {
    projectUid: String!
    projectKey: String!
    token: String!
}

type MobileTunnelConfig {
    platform: PlatformType! @enumeration
    urlScheme: String!
    spn: String
}

type MiniProgramTunnelConfig {
    #   如果命名 type 会与 FilesTunnelConfig 中的 type 冲突，在 mutation create 时候，grapqhl validate 会报错: Validation error of type FieldsConflict
    #   所以命名加了前缀 programType
    programType: MiniProgramType! @enumeration
    urlScheme: String!
}

enum FilesTunnelConfigType {
    HISTORY_EVENT
    USER_PROPERTY
    ITEM_PROPERTY
}

type FileTunnelConfig {
    type: FilesTunnelConfigType @enumeration
}

enum TunnelType {
    UBA, FILE, MOBILE, SERVER, MINI_PROGRAM, WEB
}

union TunnelConfig = JDBCTunnelConfig | GIOApiTunnelConfig | FileTunnelConfig | MobileTunnelConfig | MiniProgramTunnelConfig

input UbaUserVariableInput {
    key: String!
    name: String!
    type: String!
    description: String
    isSystem: Boolean!
}

input UbaCustomEventInput {
    key: String!
    name: String!
    valueType: String!
    variables: [UbaCustomEventVariableInput!]
    isSystem: Boolean!
}

input UbaCustomEventVariableInput {
    key: String!
    name: String!
    valueType: String!
}

input TunnelInput {
    name: String!
    type: TunnelType!
    description: String
    config: Object
}

type TunnelEventsTrend {
    totalCount: Long!
    interval: Long!
    points: [TrendPoint]! @fetch(from: "pointsList")
}


enum JobStage {
    # NONE 任务的初始状态
    # READY 任务准备执行
    # RUNNING 任务正在执行
    # DATA_READY 数据已经准备就绪
    # FINISH 任务完成
    # ERROR 任务执行失败
    NONE, READY, RUNNING, DATA_READY, FINISH, ERROR
}

type JobResult {
    id: HashId!
    stage: JobStage!
    uris: [String!] @fetch(from: "urisList")
}

type Error {
    code: String
    message: String
}

type EventImportJob implements NamedEntity {
    id: HashId!
    name: String!
    type: String @wrapper
    description: String @wrapper
    parameter: EventImportParameter!
    argument: EventImportArgument!
    stage: JobStage!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
    error: Error
}

type TagUserExportJob implements JobEntity  {
    id: String! @globalId
    name: String!
    description: String @wrapper
    stage: JobStage!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
    error: Error
}

type AnalysisExportJob implements JobEntity {
    id: String! @globalId
    stage: JobStage!
    error: Error
}

interface JobEntity {
    id: String! @globalId
    stage: JobStage!
    error: Error
}

input AnalysisExportJobParam {
    analysisType: AnalysisResourceType!
}

enum AnalysisResourceType {
    CHARTS,
    FUNNELS,
    RETENTIONS,
    FREQUENCIES
}

type SegmentUserExportJob implements JobEntity {
    id: String! @globalId
    name: String!
    description: String @wrapper
    stage: JobStage!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
    error: Error
}

type EventImportParameter {
    tunnelId: HashId!
    timeRange: String!
}

type EventImportArgument {
    timeRange: String!
    directory: String!
}

type FileDescriptor {
    name: String!
    owner: String!
    size: Long!
    checksum: String!
    lastModified: DateTime!
}

enum JobOperation {
    CREATE, FILE_UPLOAD, EXECUTE
}

type LogEntry {
    operation: String!
    message: String!
    operatorId: HashId!
    timestamp: DateTime!
    operator: String! @operator
}

type Order {
    id: String @wrapper
    isDim: Boolean
    index: Int @wrapper
    valueIndex: Int @wrapper
    orderType: String
}

type Splitter {
    key: String!
    values: [String] @fetch(from: "valuesList")
    users: [TargetUser] @fetch(from: "usersList")
    actions: [Action] @fetch(from: "actionsList")
    splitters: [Splitter] @fetch(from: "splittersList")
    selectedValues: [String] @fetch(from: "selectedValuesList")
    selectedIndices: [Int] @fetch(from: "selectedIndicesList")
    valueType: String @wrapper
    name: String @wrapper
}

type Action {
    measurement: Measurement
    excluded: Boolean
    eventType: String
}

type TargetUser {
    id: String!
    name: String @wrapper
}

type Granularity {
    id: String,
    values: [String] @fetch(from: "valuesList")
    interval: Long @wrapper
    split: Float @wrapper
    statistics: [String] @fetch(from: "statisticsList")
    ranges: [Float] @fetch(from: "rangesList")
    top: Int @wrapper
    period: String @wrapper
    trend: Boolean
}

type KpiAnalysis implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String @wrapper
    measurements: [Measurement]! @fetch(from: "measurementsList")
    limit: Int
    timeRange: String
    interval: Long
    filter: Filter
    goal: Float
    targetUser: TargetUser
    splitter: Splitter
    isSystem: Boolean
    businessType: String
    creatorId: HashId!,
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime @nullable
    creator: String @operator
    updater: String @operator
}

type FunnelAnalysis implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String @wrapper
    measurements: [Measurement]! @fetch(from: "measurementsList")
    conversionWindow: Int
    timeRange: String
    targetUser: TargetUser
    filter: Filter
    splitter: Splitter
    isSystem: Boolean
    businessType: String
    creatorId: HashId!,
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime @nullable
    creator: String @operator
    updater: String @operator
}

type FrequencyAnalysis implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String @wrapper
    measurements: [Measurement]!  @fetch(from: "measurementsList"),
    dimensions: [String]  @fetch(from: "dimensionsList")
    granularities: [Granularity] @fetch(from: "granularitiesList")
    timeRange: String!
    filter: Filter @nullable
    splitter: Splitter @nullable
    targetUser: TargetUser
    chartType: String
    isSystem: Boolean
    businessType: String
    creatorId: HashId!,
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime @nullable
    creator: String @operator
    updater: String @operator
}

type EventAnalysis implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String @wrapper
    measurements: [Measurement]!  @fetch(from: "measurementsList"),
    dimensions: [String]  @fetch(from: "dimensionsList")
    granularities: [Granularity] @fetch(from: "granularitiesList")
    timeRange: String!
    filter: Filter
    targetUser: TargetUser
    limit: Int @wrapper,
    attrs: BytesJson
    orders: [Order] @fetch(from: "ordersList")
    splitter: Splitter
    chartType: String
    isSystem: Boolean
    businessType: String
    creatorId: HashId!,
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime @nullable
    creator: String @operator
    updater: String @operator
}

type RetentionAnalysis implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String @wrapper
    measurements: [Measurement]!  @fetch(from: "measurementsList"),
    range: String!
    eventType: String @wrapper
    timeRange: String!
    targetUser: TargetUser
    currentTurn: Int
    splitter: Splitter
    chartType: String!
    creatorId: HashId!,
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime @nullable
    creator: String @operator
    updater: String @operator
}

type Dashboard implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String @wrapper
    components:[Component] @fetch(from: "componentsList")
    filter: Filter
    creatorId: HashId!,
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime @nullable
    creator: String @operator
    updater: String @operator
    readers: [Member!] @collaborators(resource: "dashboard", operation: "read")
    editors: [Member!] @collaborators(resource: "dashboard", operation: "edit")
}

type Component {
    projectId: HashId!
    dashboardId: HashId!
    resourceType: String!
    resourceId: HashId!
    layout: Layout
}

type DashboardReference {
    id: HashId!
    name: String!
    creatorId: HashId!
    creator: String! @operator
}

type Layout {
    y: Int
    w: Int
    h: Int
    x: Int
    minW: Int @wrapper
    minH: Int @wrapper
    moved: Boolean @wrapper
    static: Boolean @wrapper
    isDraggable: Boolean @wrapper
    isResizable: Boolean @wrapper
}

input OrderInput {
    id: String
    isDim: Boolean!
    index: Int
    valueIndex: Int
    orderType: String!
}

input GranularityInput {
    id: String,
    values: [String]
    interval: Long
    split: Float
    statistics: [String]
    ranges: [Float]
    top: Int
    period: String
    trend: Boolean
}

input SplitterInput {
    key: String!
    values: [String]
    users: [TargetUserInput]
    actions: [ActionInput]
    splitters: [SplitterInput]
    selectedValues: [String]
    selectedIndices: [Int]
    valueType: String
}

input ActionInput {
    measurement: MeasurementInput
    excluded: Boolean
    eventType: String
}

input TargetUserInput {
    id: String!
}

input KpiAnalysisInput {
    name: String
    description: String
    measurements: [MeasurementInput]!,
    limit: Int = 10
    targetUser: TargetUserInput!
    timeRange: String!
    interval: Long = 3600000
    filter: FilterInput
    goal: Float = 0.0
    splitter: SplitterInput
}

input FunnelAnalysisInput {
    name: String!
    description: String
    measurements: [MeasurementInput]!
    conversionWindow: Int
    timeRange: String!
    targetUser: TargetUserInput!
    filter: FilterInput
    splitter: SplitterInput
}

input FrequencyAnalysisInput  {
    name: String!
    description: String
    measurements: [MeasurementInput]!,
    dimensions: [String]
    granularities: [GranularityInput]
    timeRange: String!
    filter: FilterInput
    splitter: SplitterInput
    targetUser: TargetUserInput
    chartType: String!
}

input EventAnalysisInput  {
    name: String!
    description: String
    measurements: [MeasurementInput]!,
    dimensions: [String]
    granularities: [GranularityInput]
    timeRange: String!
    targetUser: TargetUserInput
    splitter: SplitterInput
    filter: FilterInput
    attrs: Object
    limit: Int
    orders: [OrderInput]
    chartType: String!
}

input RetentionAnalysisInput  {
    name: String!
    description: String
    measurements: [MeasurementInput!],
    range: String!
    eventType: String
    timeRange: String!
    targetUser: TargetUserInput!
    splitter: SplitterInput
    currentTurn: Int = 1
    chartType: String!
}

input DashboardInput {
    name: String!
    description: String
    components:[ComponentInput]
    filter: FilterInput
}

input ComponentInput {
    resourceType: String!
    resourceId: HashId!
    layout: LayoutInput
}

input LayoutInput {
    y: Int!
    w: Int!
    h: Int!
    x: Int!
    minW: Int = null
    minH: Int = null
    moved: Boolean = false
    static: Boolean = false
    isDraggable: Boolean = true
    isResizable: Boolean = true
}

input DashboardCommentInput {
    title: String!
    detail: String
}

type DashboardComment {
    id: HashId!
    title: String!
    detail: String @wrapper
    creatorId: HashId!,
    createdAt: DateTime!
    updaterId: HashId @wrapper
    updatedAt: DateTime @nullable
}

input FunnelDrillDownSegmentInput {
    name: String!
    position: Int!
    excluded: Boolean!
    scheduler: SchedulerType!
    dimensionValue: String
    targetUser: TargetUserInput
    analysis: FunnelAnalysisInput!
}

input RetentionDrillDownSegmentInput {
    name: String!
    time: Long!
    timeIndex: Int!
    excluded: Boolean!
    scheduler: SchedulerType!
    dimensionValue: String
    action: ActionInput
    targetUser: TargetUserInput
    triggerTimeRange: String!
    returnTimeRange: String!
    analysis: RetentionAnalysisInput!
}

input FrequencyDrillDownSegmentInput {
    name: String!
    lowerBound: Float!
    upperBound: Float!
    dimensionValue: String
    targetUser: TargetUserInput
    scheduler: SchedulerType!
    analysis: FrequencyAnalysisInput!
}

type DrillDownSegmentReply {
    id: HashId!
}

type DrillDownSegmentSnapshotReply {
    id: String!
}

type Feature {
    # 目前 id 的值为 [segment, tag, funnle-analysis, retention-analysis, chart-analysis, kpi-analysis]
    id: String!
    label: String!
}
directive @memberDirectDepartment on FIELD_DEFINITION

type Member {
    id: HashId!
    name: String @wrapper
    source: String!
    avatar: String @wrapper
    email: String @wrapper
    createdAt: DateTime!
    phoneNumber: String @wrapper
    directDepartment: Department @memberDirectDepartment
    identity: String @wrapper
}

type CreateAccountReply {
    account: Member!
    passwordResetUri: String!
}

input MemberInput {
    name: String!
    email: String!
    password: String!
    role: HashId!,
    department: String
    phoneNumber: String
    identity: String
}

input ResetPasswordInput {
    id: HashId!,
    password: String!
}

scalar HashId
scalar DateTime
scalar Long
scalar Object
scalar BytesJson
directive @pagination on OBJECT
directive @filterName on OBJECT
directive @seq on FIELD_DEFINITION
directive @option on FIELD_DEFINITION
directive @wrapper on FIELD_DEFINITION
directive @nullable on FIELD_DEFINITION
directive @fetch(from: String!) on FIELD_DEFINITION
directive @sensitive(type: String) on FIELD_DEFINITION
directive @operator on FIELD_DEFINITION
directive @enumeration on FIELD_DEFINITION
directive @globalId on FIELD_DEFINITION
directive @collaborators(resource: String!, operation: String!) on FIELD_DEFINITION

interface NamedEntity {
    id: HashId!
    name: String!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
}

type SlicePagination @pagination {
    offset: Int
    limit: Int
    totalCount: Int
    hasNextPage: Boolean
    hasPreviousPage: Boolean
    values: [Entity]!
}

type CursorPagination @pagination {
    totalCount: Int!
    startCursor: String
    endCursor: String
    hasNextPage: Boolean
    hasPreviousPage: Boolean
    values: [Entity]!
}

type Measurement {
    id: String!
    type: String!
    filter: Filter
    name: String @wrapper
    action: String @wrapper
    timeRange: String @wrapper
    attribute: String @wrapper
    aggregator: String @wrapper
    weight: Float @wrapper
}

type Filter @filterName {
    key: String @wrapper
    op: String @wrapper
    name: String
    values: [String] @fetch(from: "valuesList")
    exprs: [Filter] @fetch(from: "exprsList")
    valueType: String @wrapper
}

type ValueType {
    type: PrimitiveType!
    unit: ValueUnit
    isArray: Boolean
}

enum PrimitiveType {
    INT, STRING, DOUBLE, DATE
}

enum ValueUnit {
    COUNT
    DISTINCT
}

type Detector {
    stage: DetectedStage!
    description: String @wrapper
    detectedAt: DateTime
    totalUsers: Int @wrapper
    usersRatio: Float @wrapper
}

type Property {
    key: String!
    name: String @wrapper
    value: String @wrapper @sensitive
}

type InsensitiveProperty {
    key: String!
    name: String @wrapper
    value: String @wrapper
}

enum DetectedStage {
    NONE, READY, RUNNING, FINISH, ERROR
}

input MeasurementInput {
    id: String!
    type: String!
    action: String
    filter: FilterInput
    attribute: String
    aggregator: String
    timeRange: String
    weight: Float
}

input FilterInput {
    key: String
    op: String
    name: String
    values: [String]
    exprs: [FilterInput]
    valueType: String
}

union Entity = UserSummary | Tag | Segment | Tunnel | UserEvent

enum MiniProgramType {
    ALIP,
    WXWV,
    WECHAT,
    MINP,
    QQ,
    WXOA,
    BAIDUP,
    BYTEDANCE,
    QUICKAPP,
    MINIGAME
}

enum PlatformType {
    ANDROID, IOS, WEB, MINP
}

type CustomEvent implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    key: String!
    description: String
    isSystem: Boolean!
    valueType: String!
    variables: [EventVariable!]
    attributes: [CustomEventChild!] @fetch(from: "attributesList")
    itemModels: [CustomEventChild!] @fetch(from: "itemModelsList")
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
}

type CustomEventChild {
    id: HashId!
    key: String!
    name: String!
    valueType: String!
    associatedAt: DateTime
}

type EventVariable implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    key: String!
    description: String
    valueType: String!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
}

type ItemVariable implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    key: String!
    description: String
    valueType: String!
    isPrimaryKey: Boolean!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
}

type ItemModel implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String
    attributes: [ItemVariable]! @fetch(from: "attributesList")
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
}

type ComplexMetric implements NamedEntity {
    id: HashId!
    name: String!
    description: String
    expression: Expression
    isSystem: Boolean!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
}

type Expression {
    op: String!
    exprs: [Expression] @fetch(from: "exprsList")
    measurements: [Measurement] @fetch(from: "measurementsList")
}

type PreparedMetric {
    id: String!
    name: String!
    description: String
    instruction: String!
    platforms: [String]! @fetch(from: "platformsList")
}

type UserVariable implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    key: String!
    type: String!
    description: String
    isSystem: Boolean!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
    valueType: String!
}

type UserProperty {
    id: String!
    key: String!
    name: String!
    platform: String!
    description: String
    example: String
}

type PreparedDimension {
    id: String!
    name:String!
    platforms: [String]! @fetch(from: "platformsList")
    description: String
    example: String
}

type Measurable {
    id: String!
    name: String!
    type: String!
    action: String
    elementId: String
    valueType: String
    platforms: [String] @fetch(from: "platformsList")
    attributes: [MeasurableAttribute] @fetch(from: "attributesList")
    labels: [String] @fetch(from: "labelsList")
    favorites: Boolean
    #用户分群和分层/累计值标签，下面两种需要标记禁用
    #1.计算指标中含有打点事件且为人数的
    #2.计算指标含有用户量
    isComplexDistinct: Boolean
}

type MeasurableAttribute {
    id: String!
    name: String!
    valueType: String!
}

type Dimension {
    id: String!
    name: String!
    type: String!
    groupId: String!
    groupName: String
    valueType: String @wrapper
}

input CustomEventInput {
    name: String!
    key: String!
    description: String
    valueType: String!
    attributes: [EventAttributes!]
    itemModels: [EventAttributes!]
}

input ComplexMetricInput {
    name: String!
    description: String
    expression: ExpressionInput
}

input ExpressionInput {
    op: String!
    exprs: [ExpressionInput]
    measurements: [MeasurementInput]
}

input EventAttributes {
    id: HashId!
}

input VariableInput {
    name: String!
    key: String!
    description: String
    valueType: String
}

input ItemVariableInput {
    name: String!
    key: String!
    isPrimaryKey: Boolean!
    description: String
    valueType: String!
}

input ItemModelInput {
    name: String!
    description: String
    attributes: [ItemVariableInput!]
}

enum SchedulerType {
    DAILY
    ONCE
    WEEKLY
}

enum TagType {
    HORIZONTAL
    AGGREGATED
    TOP_N_ATTRIBUTE
    DATA_SET_ATTRIBUTE
    ATTRIBUTION_ATTRIBUTE
}

enum SegmentCreatedByType {
    DIRECT
    FROM_FILES
    FROM_FUNNEL
    FROM_RETENTION
    FROM_FREQUENCY
    FROM_WXAPP
    FROM_SHARE_CHAIN
}

type ComputeDefinition {
    name: String @wrapper
    expression: String!
    directives: [ComputeDirective]! @fetch(from: "directivesList")
    drillDownAttrs: Object
}

type ComputeDirective {
    alias: String!
    measurement: Measurement!
    timeRange: String
    filter: Filter
    op: String @wrapper
    attribute: String @wrapper
    aggregator: String @wrapper
    values: [String] @fetch(from: "valuesList")
}

type Tag implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    type: String!
    description: String
    computes: [ComputeDefinition]! @fetch(from: "computesList")
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
    valueType: ValueType
    detector: Detector
}

type Segment implements NamedEntity {
    id: HashId!
    projectId: HashId!
    name: String!
    description: String
    compute: ComputeDefinition!
    scheduler: String!
    creatorId: HashId!
    createdAt: DateTime!
    updaterId: HashId
    updatedAt: DateTime
    creator: String @operator
    updater: String @operator
    createdBy: String
    detector: Detector
}

type UserSummary {
    id: String!
    userId: String!
    monthlyVisits: Int!
    visitedAt: DateTime
    visitedLocation: String!
}

enum UserQueryType {
    TAG, SEGMENT, SNAPSHOT_SEGMENT, PREPARED_SEGMENT
}

type UserSearch {
    id: String!
    userId: String
    property: Property!
}

type UserProfile {
    id: String!
    userId: String!
    properties: [InsensitiveProperty] @fetch(from: "propertiesList")
}

type BasicProfile {
    id: String!
    userId: String!
    name: String @wrapper
    email: String @wrapper @sensitive
    avatar: String @wrapper
    mobile: String @wrapper @sensitive
    createdAt: DateTime
    wechatOpenId: String @wrapper
    properties: [Property] @fetch(from: "propertiesList")
}

type PersonaProfile {
    id: String!
    name: String @wrapper
    properties: [Property] @fetch(from: "propertiesList")
}

type EventTrend {
    interval: Long!
    points: [TrendPoint]! @fetch(from: "pointsList")
}

type TrendPoint {
    timestamp: Long!
    count: Int!
}

type SegmentSnapshot {
    id: String!
    projectId: HashId!
    totalUsers: Int
    usersRatio: Float
}

type PreparedSegment {
    id: String!
    name: String!
    detector: Detector
}

type UserEvent {
    name: String
    type: UserEventType!
    key: String @wrapper
    timestamp: DateTime
    properties: [Property!] @fetch(from: "propertiesList")
}

type SegmentDocument {
    id: HashId!
    fileName: String!
    sourceType: String!
}

enum UserEventType {
    ALL, VISIT, CUSTOM_EVENT, PAGE, UNKNOWN
}

input TagInput {
    name: String!
    type: TagType!
    description: String
    computes: [ComputeDefinitionInput]!
}

input SegmentInput {
    name: String!
    description: String
    compute: ComputeDefinitionInput!
    scheduler: SchedulerType!
    createdBy: SegmentCreatedByType!
}

input ComputeDefinitionInput {
    name: String
    expression: String!
    directives: [ComputeDirectiveInput]!
}

input ComputeDirectiveInput {
    alias: String!
    measurement: MeasurementInput!
    op: String
    values: [String]
    timeRange: String
    attribute: String
    aggregator: String
    filter: FilterInput
}

input SegmentMeasurementInput {
    measurement: MeasurementInput!
    timeRange: String!
}

